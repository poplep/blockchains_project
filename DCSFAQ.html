<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
        <link href="https://fonts.googleapis.com/css?family=Pavanam" rel="stylesheet">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>Blockchain UI</title>
         <!-- Bootstrap CSS CDN -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
        <!-- Our Custom CSS -->
        <link rel="stylesheet" href="style4.css">
        <!-- Check browser - if its not firefox or chrome, then let the user know -->
<script>
        
        // original source: http://www.javascriptkit.com/script/script2/alertmsg.shtml
        // modified
        var once_per_session = 1;
        
        function get_cookie(Name) {
            var search = Name + "="
            var returnvalue = "";
            if (document.cookie.length > 0) {
                offset = document.cookie.indexOf(search)
                if (offset != -1) { // if cookie exists
                    offset += search.length
                    // set index of beginning of value
                    end = document.cookie.indexOf(";", offset);
                    // set index of end of cookie value
                    if (end == -1)
                        end = document.cookie.length;
                    returnvalue=unescape(document.cookie.substring(offset, end))
                }
            }
            return returnvalue;
        }
        function alertornot(){
            if (get_cookie('alerted')==''){
                loadalert()
                document.cookie="alerted=yes"
                //check if the user is logged into metamask
                web3.eth.getAccounts(function(err, accounts){
                    if (err != null) alert("An error occurred: "+err);
                    else if (accounts.length == 0) alert("It doesn't seem like you're logged into Metamask. Please log into the LocalHost and try again.");
                    else alert("Successfully logged into Metamask.");
                });
            }
        }
        function loadalert(){
             //Check if browser is IE
             if (navigator.userAgent.search("MSIE") >= 0) {
                // insert conditional IE code here
                var isIE = true;
            }
            //Check if browser is Chrome
            else if (navigator.userAgent.search("Chrome") >= 0) {
                // insert conditional Chrome code here
                var isChrome = true;
            }
            //Check if browser is Firefox 
            else if (navigator.userAgent.search("Firefox") >= 0) {
                // insert conditional Firefox Code here
                var isFirefox = true;
            }
            //Check if browser is Safari
            else if (navigator.userAgent.search("Safari") >= 0 && navigator.userAgent.search("Chrome") < 0) {
                // insert conditional Safari code here
                var isSafari = true;
            }
            //Check if browser is Opera
            else if (navigator.userAgent.search("Opera") >= 0) {
                // insert conditional Opera code here
                var isOpera = true;
            }
            
            // Chromium (checks if there are any chromium plugins present that wouldnt be in chrome)
            var isChromium = function isChromium(){ 
                    for (var i = 0, u="Chromium", l =u.length; i < navigator.plugins.length; i++)
                    {
                        if (navigator.plugins[i].name != null && navigator.plugins[i].name.substr(0, l) === u)
                            return true;
                    }
                    return false;
                }
            // if the user isnt using firefox, chrome, chromium, or opera
            if(isFirefox == false || isChrome == false || isOpera == false || isChromium == false) {
                alert("You are not using a compatible browser. Please switch to Mozilla Firefox, Google Chrome or Opera.");
            }
            if(isSafari == true || isIE == true) {
                alert("You are not using a compatible browser. Please switch to Mozilla Firefox, Google Chrome or Opera.");
            }
            //if metamask isnt installed
            if(typeof web3 == "undefined") {
                alert("It looks like you don't have MetaMask installed. Please install it as a browser extension and restart your browser. Install Metamask here: https://metamask.io");
            }
        }
        if (once_per_session==0){
            loadalert()
        }else{
            alertornot()
        }
</script>
    </head>
    <!-- Style for the tile buttons -->
<style>
        div.gallery {
            margin: 5px;
            float: left;
            width: 1000px;
            border-radius: 20px 20px 0px 0px;
        }
        
        
        div.gallery img {
            width: 100%;
            height: 500px;
            border-radius: 20px 20px 0px 0px;
    
        }
        
        div.desc {
            padding: 15px;
            text-align: center;
            background-color: rgb(49, 57, 77);
            color: white;
            border-radius: 0px 0px 20px 20px;
    
    
        }
        </style>
    <style>
        /*
    DEMO STYLE
*/
@import "https://fonts.googleapis.com/css?family=Pavanam:300,400,500,600,700";
.w3-container {
            background-color:rgb(49, 57, 77);
        }
body {
    font-family: 'Pavanam', sans-serif;
    background: #fafafa;
    font-size: 18px;
}
p {
    font-family: 'Pavanam', sans-serif;
    font-size: 20px;
}
a, a:hover, a:focus {
    color: inherit;
    text-decoration: none;
    transition: all 0.3s;
}
.navbar {
    padding: 15px 10px;
    background: #fff;
    border: none;
    border-radius: 0;
    margin-bottom: 40px;
    box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.1);
}
.navbar-btn {
    box-shadow: none;
    outline: none !important;
    border: none;
}
.line {
    width: 100%;
    height: 1px;
    border-bottom: 1px dashed #ddd;
    margin: 40px 0;
}
i, span {
    display: inline-block;
}
/* ---------------------------------------------------
    SIDEBAR STYLE
----------------------------------------------------- */
.wrapper {
    display: flex;
    align-items: stretch;
}
#sidebar {
    min-width: 300px;
    max-width: 300px;
    background: rgb(49, 57, 77);
    color: #fff;
    transition: all 0.3s;
}
#sidebar.active {
    min-width: 100px;
    max-width: 100px;
    text-align: center;
}
#sidebar.active .sidebar-header h3, #sidebar.active .CTAs {
    display: none;
}
#sidebar.active .sidebar-header strong {
    display: block;
}
#sidebar ul li a {
    text-align: left;
}
#sidebar.active ul li a {
    padding: 20px 10px;
    text-align: center;
    font-size: 0.85em;
}
.w3-container {
            background-color:rgb(49, 57, 77);
        }
#sidebar.active ul li a i {
    margin-right:  0;
    display: block;
    font-size: 1.8em;
    margin-bottom: 5px;
}
#sidebar.active ul ul a {
    padding: 10px !important;
}
#sidebar.active a[aria-expanded="false"]::before, #sidebar.active a[aria-expanded="true"]::before {
    top: auto;
    bottom: 5px;
    right: 50%;
    -webkit-transform: translateX(50%);
    -ms-transform: translateX(50%);
    transform: translateX(50%);
}
#sidebar .sidebar-header {
    padding: 20px;
    background: rgb(49, 57, 77);
}
#sidebar .sidebar-header strong {
    display: none;
    font-size: 1.8em;
}
#sidebar ul.components {
    padding: 20px 0;
    border-bottom: 1px solid #47748b;
}
#sidebar ul li a {
    padding: 10px;
    font-size: 1.1em;
    display: block;
}
#sidebar ul li a:hover {
    color: rgb(49, 57, 77);
    background: #fff;
}
#sidebar ul li a i {
    margin-right: 10px;
}
#sidebar ul li.active > a, a[aria-expanded="true"] {
    color: #fff;
    background: rgb(100, 117, 160);
}
a[data-toggle="collapse"] {
    position: relative;
}
a[aria-expanded="false"]::before, a[aria-expanded="true"]::before {
    content: '\e259';
    display: block;
    position: absolute;
    right: 20px;
    font-family: 'Glyphicons Halflings';
    font-size: 0.6em;
}
a[aria-expanded="true"]::before {
    content: '\e260';
}
ul ul a {
    font-size: 0.9em !important;
    padding-left: 30px !important;
    background: rgb(49, 57, 77);
}
ul.CTAs {
    padding: 20px;
}
ul.CTAs a {
    text-align: center;
    font-size: 0.9em !important;
    display: block;
    border-radius: 5px;
    margin-bottom: 5px;
}
a.download {
    background: rgb(100, 117, 160);
    color: white;
}
a.article, a.article:hover {
    background: rgb(100, 117, 160) !important;
    color: #fff !important;
}
/* ---------------------------------------------------
    CONTENT STYLE
----------------------------------------------------- */
#content {
    min-height: 100vh;
    transition: all 0.3s;
}
/* ---------------------------------------------------
    MEDIAQUERIES
----------------------------------------------------- */
@media (max-width: 768px) {
    #sidebar {
        min-width: 100px;
        max-width: 100px;
        text-align: center;
        margin-left: -80px !important ;
    }
    a[aria-expanded="false"]::before, a[aria-expanded="true"]::before {
        top: auto;
        bottom: 5px;
        right: 50%;
        -webkit-transform: translateX(50%);
        -ms-transform: translateX(50%);
        transform: translateX(50%);
    }
    #sidebar.active {
        margin-left: 0 !important;
    }
    #sidebar .sidebar-header h3, #sidebar .CTAs {
        display: none;
    }
    #sidebar .sidebar-header strong {
        display: block;
    }
    #sidebar ul li a {
        padding: 20px 10px;
    }
    #sidebar ul li a span {
        font-size: 0.85em;
    }
    #sidebar ul li a i {
        margin-right:  0;
        display: block;
    }
    #sidebar ul ul a {
        padding: 10px !important;
    }
    #sidebar ul li a i {
        font-size: 1.3em;
    }
    #sidebar {
        margin-left: 0;
    }
    #sidebarCollapse span {
        display: none;
    }
}
    </style>
    <body>

		<!-- Question Modal-->
<div class="container">
  
        <!-- Modal Window -->
        <div class="modal fade" id="QuestionForm" role="dialog">
          <div class="modal-dialog">
          
            <!-- Modal content-->
            <div class="modal-content" id="AddBlockContent" >
              <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal">&times;</button>
                <h4 class="modal-title">Ask a Question!</h4>
              </div>
              <div class="modal-body">
					<form action="https://formspree.io/vsoares1@umassd.edu"  method="POST">
						<input type="text" name="Bug Description: " style="height: 200px; width: 550px">
						
						<input type="hidden" name="_next" value="http://134.88.13.89/DCSFAQ.html" />
						<div class="modal-footer">
								<input type="submit" value="Send">
							<button class="btn btn-default" id="exit1" data-dismiss="modal">Cancel</button>
			
						  </div>
					</form>
              </div>
             
            </div>
            
          </div>
        </div>
        
      </div>

        <div class="wrapper">
            <!-- Sidebar Holder -->
            <nav id="sidebar">
                
                <div class="sidebar-header">
                    <h3><a href="HomePage.html">Home</a></h3>
                    <strong><a href="HomePage.html">BC</a></strong>                </div>
                <ul class="list-unstyled components">
                    <li class="active">
                        <a href="#homeSubmenu" data-toggle="collapse" aria-expanded="false">
                            
                            Blockchains
                        </a>
                        <ul class="collapse list-unstyled in" id="homeSubmenu">
                            <li><a href="Blockchain.html">About the Blockchain</a></li>
                            <li><a href="BlockchainFAQ.html">FAQ</a></li>
                            <li><a href="BlockchainAbout.html">About our Application</a></li>
                            <li><a href="Guide.html">A Guide to Decentralized Consensus Systems</a></li>
                            <li><a href="BlockchainDataLossTampering.html">Blockchains for Data Loss and Tampering</a></li>
                        </ul>
                    </li>
                    <li>
                        
                        <a href="#pageSubmenu" data-toggle="collapse" aria-expanded="false">
                            
                            Blockchain Functionality
                        </a>
                        <ul class="collapse list-unstyled" id="pageSubmenu">
                            <li><a href="AddBlock.html">Add a Block</a></li>
                            <li><a href="SearchBlock.html">Search for a Block</a></li>
                            <li><a href="ViewBlockAdvanced.html">Advanced View of the Blockchain</a></li>
                            <li><a href="ViewBlockLedger.html">Ledger View of the Blockchain</a></li>
                            <li><a href="BlockStats.html">Blockchain Statistics</a></li>
                        </ul>
                    </li>
                  
                    <li>
                            <a href="#pageSubmenu2" data-toggle="collapse" aria-expanded="false">
                                
                                Blockchain Alternatives
                            </a>
                            <ul class="collapse list-unstyled" id="pageSubmenu2">
                                <li><a href="HashgraphAbout.html">Hashgraph</a></li>
                                <li><a href="TangleAbout.html">Tangle</a></li>
                                <li><a href="HyperledgerAbout.html">Hyperledger</a></li>
                                <li><a href="CordaAbout.html">Corda</a></li>
                                <li><a href="DCSFAQ.html">FAQ</a></li>
                                <li><a href="DCSDataLossTampering.html">Preventing Data Loss and Tampering</a></li>
                                <li><a href="Comparison.html">Comparison</a></li>
                            </ul>
                        </li>
                </ul>
                <ul class="list-unstyled CTAs">
                    <li><a href="Help.html" class="download">Help</a></li>
                    <li><a href="ReportBug.html" class="download">Report a Bug</a></li>
                    <li><a href="Tutorial.html" class="download">Tutorial</a></li>
                   
                </ul>
                <div class="navbar-header">
                        <button type="button" id="sidebarCollapse" class="btn btn-info navbar-btn">
                            <span>Hide</span>
                        </button>
                    </div>
            </nav>
            <!-- Page Content Holder -->
            <div id="content">
                    <div class="w3-container">
							<h1 style="color: white">FAQ <img src ="ask.png" style="height: 50px; width: 50px" id="question"></h1>
						</div>
						<br>
				
				
						<div style="padding-left: 20px">
                                <b><h2>Table of Contents</h2></b>
                                <ol style="font-size: 25px;">
                                    <a href="#hashgraph" style="text-decoration: underline"><li>Hashgraph</li></a>
                                    <a href="#tangle" style="text-decoration: underline"><li>Tangle</li></a>
                                    <a href="#hyperledger" style="text-decoration: underline"><li>Hyperledger</li></a>
                                    <a href="#corda" style="text-decoration: underline"><li>Corda</li></a>
                        
                                </ol>
                                <b><a style="font-size: 30px;" name="hashgraph">Hashgraph</a></b>
                        
                                <p><b>Q: What is a hashgraph?</p></b>
                                <p><b>A:</b> A hashgraph is a data structure and consensus algorithm. It is fast, secure, and fair.</p>
                                
                                <p><b>Q:  How does a Hashgraph work?</p></b>
                                <p><b>A:</b> A hashgraph uses Gossip about Gossip and Virtual Voting techniques to achieve fast, secure, and fair consensus among nodes.</p>
                                
                                <p><b>Q:  What is Gossip about Gossip?</p></b>
                                <p><b>A:</b> Calling any random node and telling that node everything you know that it doesn't know. It refers to attaching a small additional amount of information that consists of two hashes that contain the last two people the node communicated with (gossiping about the information gossiped).</p>
                        
                                <p><b>Q: Does Hashgraph use a cryptocurrency?</p></b> 
                                <p><b>A:</b> There is no public ledger or cryptocurrency for Hashgraph. This technology is currently being implemented on permissioned/private networks.</p>
                        
                                <p><b>Q: What does Byzantine Fault Tolerance guarantee?</p></b> 
                                <p><b>A:</b> We know when we'll reach a conesnsus, have a guarantee that we'll reach that consensus, and have math proofs that make no assumptions about the Internet speed which could be impacted by firewalls, DDoS, viruses, botnets, etc. There is also fair ordering and time stamping on every event.</p>
                        
                                <p><b>Q: How fast is a Hashgraph?</p></b> 
                                <p><b>A:</b> A Hashgraph is very fast and has a low consensus latency. This lets it have a large range of use cases and applications. Performance tests are currently being conducted on this new technology.</p>
                        
                                <p><b>Q:  What is Byzantine Fault Tolerance (BFT)? </p></b>
                                <p><b>A:</b> BFT is a consensus algorithm that guarantees a moment in time that all participants reach a consensus, know that a consensus has been reached, and they are never wrong. With Blockchain's Proof-of-Work, participants slowly become more confident of consensus with every block confirmation. There are different levels of BFT which depend on network assumptions and transmissions of messages. The strongest form of BFT is asynchronous.</p>
                        
                                <p><b>Q:  What is Asynchronous BFT?</p></b>
                                <p><b>A:</b> Asynchronous BFT allows for malicious actors controlling the network and deleting/slowing down messages of their choosing. The only assumptions made are that less than 1/3 of the nodes on the network are attackers and some messages are transmitted over the internet. Some systems are partially asynchronous and are only secure if the attackers don't have too much power and don't manipulate message timing as much. </p>
                        
                                <p><b>Q:  How does hashgraph prevent Sybil attacks?</p></b>
                                <p><b>A:</b> A Sybil attack is an attempt to compromise the network by creating large numbers of identities that are directed to act in collusion to inappropriately impact the network. Protecting against Sybil attacks can be done by appropriately allocating and weighting votes of different nodes. </p>
                        
                                <p><b>Q:  How does Hashgraph prevent against DDos attacks?</p></b>
                                <p><b>A:</b> A Distributed Denial of Service (DDoS) attack occurs when its possible to disrupt transaction flow for an entire network by targeting a single or a few computers. Hashgraph doesn't use Proof-of-Work or have a leader that will solve a hash and publish a block like with Blockchain. Leader-based systems similar to the Blockchain give special permissions to a node and are very susceptible to DDoS since the current leader is a bottleneck and can be targeted.  So, Hashgraph provides DDoS resilience without the inefficiency and cost of Proof-of-Work.</p>
                        
                                <p><b>Q: How is a Hashgraph fair?</p></b> 
                                <p><b>A:</b> Fairness is the ability to prevent ordering of transactions from being unduly manipulated. Hashgraphs are fair because they serialize all transactions with cryptographic timestamping. This is different from the Blockchain since Blockchain miners determine the order in which transactions are placed in each block. Hashgraphs order transactions according to the median timestamp of when the node population received them to ensure that they are recorded fairly.</p>
                        
                                <p><b>Q: What is the Hedera hashgraph platform?</p></b> 
                                <p><b>A: </b>The Hedera hashgraph platform provides a new form of distributed consensus; a way for people who don't know or trust each other to securely collaborate and transact online without the need for a trusted intermediary. The platform is lightning fast, secure, and fair, and, unlike some blockchain-based platforms, doesn’t require compute-heavy proof-of-work. Hedera enables and empowers developers to build an entirely new class of distributed applications never before possible.</p>

                                <p><b>Q: What is the Hedera Hashgraph Council?</p></b> 
                                <p><b>A: </b>The Hedera Hashgraph Council will be the governing body of the Hedera hashgraph network. The council will consist of up to 39 leading organizations and enterprises in their respective fields, with membership designed to reflect a range of industries and geographies, to have highly respected brands and trusted market positions, and to encourage a wide variety of perspectives. The Governing Members will elect the Governing Board and also contribute expertise through subcommittee membership. Hedera’s governance terms ensure no single member will have control, and no small group of members will have undue influence over the body as a whole.</p>

                                <p><b>Q: Is the Hedera hashgraph network decentralized?</p></b> 
                                <p><b>A: </b>All Governing Members of the Hedera Hashgraph Council will have equal voting rights and all except Swirlds, Inc. will be limited to a three year term with a limit of two consecutive terms. (Swirlds, Inc., the owners and licensor of the hashgraph technology, will retain a permanent seat on the council.) The highly distributed network will expand to many millions of nodes voting on the order of transactions across at least five continents. This separation of governance from consensus is designed to ensure continued decentralization over time.</p>

                                <p><b>Q: Is there a Hedera hashgraph cryptocurrency?</p></b> 
                                <p><b>A: </b>The Hedera hashgraph network will have a native cryptocurrency, which is a utility token that grants token holders access to distributed applications on the platform. The token may also be “staked” and used to run a node (that is, adding CPU to the Hedera public network), thereby providing the network security within the public ledger. We expect the token to act as a unit of value to motivate responsible use and governance of the platform.</p>

                                <p><b>Q: Is the source code open source?</p></b> 
                                <p><b>A: </b>The Hedera hashgraph source code will be open review, which provides transparency and allows for contribution, while also bringing stability to the network by preventing forking. Forking, or splitting, is a prevalent issue with some public ledger platforms as it artificially inflates supply.</p>

                                <p><b>Q: Is the Hedera hashgraph platform patented?</p></b> 
                                <p><b>A: </b>Yes, Swirlds has granted Hedera hashgraph a license to the hashgraph consensus algorithm.</p>

                                <p><b>Q: What role does Swirlds have in the Hedera hashgraph platform?</p></b> 
                                <p><b>A: </b>Swirlds is the licensor of the underlying hashgraph technology that enables the Hedera hashgraph platform, and will continue to develop the technology. Swirlds is a member of the Hedera Hashgraph Council and will have the same voting rights as every other Governing Member. Prior to formal launch of the plaform and the council, Swirlds may retain control of governance and network development.</p>

                                <p><b>Q: Do I require a license to develop on the Hedera hashgraph platform?</p></b> 
                                <p><b>A: </b>No, you do not require a license or need permission to use, or develop on, the Hedera public network. Applications that are developed on the platform can implement any licensing model.</p>

                                <p><b>Q: Are there transaction fees?</p></b> 
                                <p><b>A: </b>Yes, token holders will pay transaction fees to access distributed applications on the Hedera hashgraph platform. These transaction fees are paid to Hedera and the nodes in the network that contribute to the consensus mechanism.</p>

                                <p><b>Q: What programming languages are available for developers?</p></b> 
                                <p><b>A: </b>The Hedera hashgraph platform will support Java™ and Solidity™.</p>

                                <p><b>Q: Who can run a node?</p></b> 
                                <p><b>A: </b>The Hedera hashgraph platform will start with a small number of nodes during the testing phase, but we anticipate this will become available to anyone who wants to host a node (and meets basic requirements for bandwidth, CPU, and storage) in the future.</p>

                                <p><b>Q: Is there a test network?</p></b> 
                                <p><b>A: </b>There is a test network currently running for Hedera Hashgraph Council members.</p>

                                <p><b>Q: When will the Hedera hashgraph platform go live?</p></b> 
                                <p><b>A: </b>We expect the beta will go live in 2018.</p>


                                <p><b>Source: hederahashgraph.com</b></p>
                                <b><a style="font-size: 30px;" name="tangle">Tangle</a></b> <br>
                                <p><b>Q: What is IOTA?</p></b> 
                                <p><b>A: </b>IOTA is an open-source distributed ledger protocol launched in 2015 that goes 'beyond blockchain' through its core invention of the blockless ‘Tangle’. The IOTA Tangle is a quantum-resistant Directed Acyclic Graph (DAG), whose digital currency 'iota' has a fixed money supply with zero inflationary cost.

                                    IOTA uniquely offers zero-fee transactions & no fixed limit on how many transactions can be confirmed per second. Scaling limitations have been removed, since throughput grows in conjunction with activity; the more activity, the more transactions can be processed and the faster the network. Further, unlike blockchain architecture, IOTA has no separation between users and validators (miners / stakers); rather, validation is an intrinsic property of using the ledger, thus avoiding centralization.
                                    
                                    IOTA is focused on being useful for the emerging machine-to-machine (m2m) economy of the Internet-of-Things (IoT), data integrity, micro-/nano- payments, and other applications where a scalable decentralized system is warranted.</p>

                                <p><b>Q: What is a seed?</p></b> 
                                <p><b>A: </b>A seed is a unique identifier that can be described as a combined username and password that grants you access to your IOTA.

                                    Your seed is used to generate the addresses and private keys you will use to store and send IOTA, so this should be kept private and not shared with anyone. If anyone obtains your seed, they can generate the private keys associated with your addresses and access your IOTA.</p>

                                <p><b>Q: What is a non reusable address and how does it work for IOTA's Tangle?</p></b> 
                                <p><b>A: </b>Contrary to traditional blockchain based systems such as Bitcoin, where your wallet addresses can be reused, IOTA's addresses should only be used once (for outgoing transfers). That means there is no limit to the number of transactions an address can receive, but as soon as you've used funds from that address to make a transaction, this address should not be used anymore.</p>

                                <p><b>Q: How does Tangle reach consensus?</p></b> 
                                <p><b>A: </b>Apart from the data structure, the other major difference is how IOTA achieves consensus and how transactions are made. As mentioned previously, there are no miners. What this means is that each participant in the network that wants to make a transaction has to actively participate in the consensus of the network by approving 2 past transactions.
                                    This attestation on the validity of two past transactions ensures that the network achieves consensus on the current state of approved transactions, and it enables a variety of unique features that are only seen in IOTA.</p>

                                <p><b>Q: How is Tangle scalable?</p></b> 
                                <p><b>A: </b>IOTA can achieve high transaction throughput thanks to parallelized validation of transactions with no limit as to the number of transactions that can be confirmed in a certain interval.</p>

                                <p><b>Q: How does decentralization work for Tangle?</p></b> 
                                <p><b>A: </b>IOTA has no miners. Every participant in the network that is making a transaction, actively participates in the consensus. As such, IOTA is more decentralized than any Blockchain.</p>

                                <p><b>Q: How is Tangle quantum-immutable?</p></b> 
                                <p><b>A: </b>IOTA utilized a next generation trinary hash function called Curl-p, which is quantum immune (Winternitz signatures).</p>

                                <p><b>Sources: https://www.reddit.com/r/Iota/comments/7irl3l/information_and_faq/, https://docs.iota.org/introduction/what-is-iota</b></p>
                                <b><a style="font-size: 30px;" name="hyperledger">Hyperledger</a></b> <br>
                        
                                <p><b>Q: How many peers in the network need to endorse a transaction?</p></b> 
                                <p><b>A: </b>The number of peers required to endorse a transaction is driven by the endorsement policy that is specified at chaincode deployment time.</p>

                                <p><b>Q: Does an application client need to connect to all peers?</p></b> 
                                <p><b>A: Clients only need to connect to as many peers as are required by the endorsement policy for the chaincode.</b></p>

                                <p><b>Q: How do I ensure data privacy?</p></b> 
                                <p><b>A:</b> There are various aspects to data privacy. First, you can segregate your network into channels, where each channel represents a subset of participants that are authorized to see the data for the chaincodes that are deployed to that channel. Second, within a channel you can restrict the input data to chaincode to the set of endorsers only, by using visibility settings. The visibility setting will determine whether input and output chaincode data is included in the submitted transaction, versus just output data. Third, you can hash or encrypt the data before calling chaincode. If you hash the data then you will need to provide a means to share the source data. If you encrypt the data then you will need to provide a means to share the decryption keys. Fourth, you can restrict data access to certain roles in your organization, by building access control into the chaincode logic. Fifth, ledger data at rest can be encrypted via file system encryption on the peer, and data in-transit is encrypted via TLS.</p>

                                <p><b>Q: Do the orderers see the transaction data?</p></b> 
                                <p><b>A:</b> No, the orderers only order transactions, they do not open the transactions. If you do not want the data to go through the orderers at all, and you are only concerned about the input data, then you can use visibility settings. The visibility setting will determine whether input and output chaincode data is included in the submitted transaction, versus just output data. Therefore, the input data can be private to the endorsers only. If you do not want the orderers to see chaincode output, then you can hash or encrypt the data before calling chaincode. If you hash the data then you will need to provide a meansto share the source data. If you encrypt the data then you will need to provide a means to share the decryption keys.</p>

                                <p><b>Q: How do application clients know the outcome of a transaction?</p></b> 
                                <p><b>A:</b> The transaction simulation results are returned to the client by the endorser in the proposal response. If there are multiple endorsers, the client can check that the responses are all the same, and submit the results and endorsements for ordering and commitment. Ultimately the committing peers will validate or invalidate the transaction, and the client becomes aware of the outcome via an event, that the SDK makes available to the application client.</p>

                                <p><b>Q: How do I query the ledger data?</p></b> 
                                <p><b>A:</b> Within chaincode you can query based on keys. Keys can be queried by range, and composite keys can be modeled to enable equivalence queries against multiple parameters. For example a composite key of (owner,asset_id) can be used to query all assets owned by a certain entity. These key-based queries can be used for read-only queries against the ledger, as well as in transactions that update the ledger.

                                    If you model asset data as JSON in chaincode and use CouchDB as the state database, you can also perform complex rich queries against the chaincode data values, using the CouchDB JSON query language within chaincode. The application client can perform read-only queries, but these responses are not typically submitted as part of transactions to the ordering service.</p>
                               
                                <p><b>Q: How do I query the historical data to understand data provenance?</p></b> 
                                <p><b>A:</b> The chaincode API GetHistoryForKey() will return history of values for a key.</p>

                                <p><b>Q: How to guarantee the query result is correct, especially when the peer being queried may be recovering and catching up on block processing?</p></b> 
                                <p><b>A:</b> The client can query multiple peers, compare their block heights, compare their query results, and favor the peers at the higher block heights.</p>
                                <p><b>Q: Does Hyperledger Fabric support smart contract logic?</p></b> 
                                <p><b>A:</b> Yes. We call this feature Chaincode. It is our interpretation of the smart contract method/algorithm, with additional features.

                                    A chaincode is programmatic code deployed on the network, where it is executed and validated by chain validators together during the consensus process. Developers can use chaincodes to develop business contracts, asset definitions, and collectively-managed decentralized applications.</p>

                                <p><b>Q: How do I create a business contract?</p></b> 
                                <p><b>A:</b>  There are generally two ways to develop business contracts: the first way is to code individual contracts into standalone instances of chaincode; the second way, and probably the more efficient way, is to use chaincode to create decentralized applications that manage the life cycle of one or multiple types of business contracts, and let end users instantiate instances of contracts within these applications.</p>
                                <p><b>Q: How do I create assets?</p></b> 
                                <p><b>A:</b> Users can use chaincode (for business rules) and membership service (for digital tokens) to design assets, as well as the logic that manages them.

                                    There are two popular approaches to defining assets in most blockchain solutions: the stateless UTXO model, where account balances are encoded into past transaction records; and the account model, where account balances are kept in state storage space on the ledger.
                                    
                                    Each approach carries its own benefits and drawbacks. This blockchain technology does not advocate either one over the other. Instead, one of our first requirements was to ensure that both approaches can be easily implemented.</p>

                                <p><b>Q: Which languages are supported for writing chaincode?</p></b> 
                                <p><b>A:</b> Chaincode can be written in any programming language and executed in containers. The first fully supported chaincode language is Golang.

                                    Support for additional languages and the development of a templating language have been discussed, and more details will be released in the near future.
                                    
                                    It is also possible to build Hyperledger Fabric applications using Hyperledger Composer.</p>
                                <p><b>Q: Does the Hyperledger Fabric have native currency?</p></b> 
                                <p><b>A:</b> No. However, if you really need a native currency for your chain network, you can develop your own native currency with chaincode. One common attribute of native currency is that some amount will get transacted (the chaincode defining that currency will get called) every time a transaction is processed on its chain.</p>


                                <p><b>Source: hyperledger-fabric.readthedocs.io</b></p>
                                <b><a style="font-size: 30px;" name="corda">Corda</a></b><br>
                                <p><b>Q: How does Corda prove that a party owns the cash or securities?</p></b> 
                                <p><b>A: </b>Corda lets you provide the full history of the money back to when it was issued or you can have the issuer re-sign/countersign every time that money is moved so the issuer signature stays with the asset, only ever having to reach back far enough to find a signature from the issuer. Once you’re happy that you each own what you’re saying you own, you both sign it and the transaction becomes valid, and private at that point.</b></p>

                                <p><b>Q: How does Corda solve the double spending problem?</p></b> 
                                <p><b>A: </b>Two transactions for the same thing can’t happen (double spend) because Corda distinguishes between, is this transaction valid (an acceptable transaction) and is it confirmed (no double spend by notarization)? It sends a request to a notary cluster that along the lines, says, please confirm these assets haven’t been spent. The notary then replies yes or no. This is operated either by a cluster using a Byzantine Fault-Tolerant algorithm or by a CSD. You can have several notaries in the system.

                                    When the transaction is confirmed, it is important to know it’s confirmed with finality and you cannot go back. The notary clusters – likely in different jurisdictions – will likely be regulated and covered by things like settlement finality obligation, controls, etc. Therefore, Corda can allow several notaries on the system, so that you can use a regulated one when you need to and a non-regulated one when appropriate.</b></p>

                                <p><b>Q: What do you mean by physical separation of ledgers?</p></b> 
                                <p><b>A: </b>It means there should be physically distinct nodes for certain client segments.</b></p>

                                <p><b>Q: Where are smart contracts stored?</p></b> 
                                <p><b>A: </b>In Corda, every state object contains the identity of the Smart Contract that controls it. If I’m in a cash contract, I will point to the Smart Contract that requires payment. The code is written in Java and is identified by a hash. The code can move around the network in that hash. Imagine it flowing across the network wherever the agreement goes. You can check by the hash that it is the correct version of the agreement, and hasn’t been tampered with.</b></p>

                                <p><b>Q: How does Corda validate the amount of the transaction?</p></b> 
                                <p><b>A: </b>You can put a requirement in the verify() function of the contract of the output state stating that the sum of the value of all cash inputs must be of a certain value, that there are no other inputs, and that there is a single output.</b></p>

                                <p><b>Q: What is the role of homomorphic encryption in the financial services industry?</p></b> 
                                <p><b>A: </b>Homomorphic encryption have a role to play but as part of a broader overall strategy. Platforms that start by sharing data indiscriminately and inappropriately and then later encrypting it seems like the incorrect way to do it. For example, the equivalent would be if we do a loan, and you lend me the money. I’ll then make 1,000 copies of the loan note and share it with everyone. That doesn’t make sense. But what if I make the 1,000 copies and put them in 1,000 safes and then share those. Not everyone should be able to see it. But why share it if everyone can’t see it? However, in our system, some data does have to be shared to prove it’s correct, and then that creates a privacy leak. It’s a balancing act.

                                    We’ve made it as secure as we can without advanced encryption. We have pluggable consensus – you can apply any style of verification to prevent double spend for each state. It is a small part called the verification step which in the future can be converted into an efficient zero knowledge proof. We have done work to allow us to use zero knowledge proofs in the future.</b></p>

                                <p><b>Q: How are documents related to transactions handled in Corda?</p></b> 
                                <p><b>A: </b>The proposed application can be configured to support uploading of documents for every individual trade. The documents so uploaded may be stored within the transaction, on public or private cloud, and also may be sent as part of notifications to the registered email id. The said documents would be accessible only to the relevant parties.

                                    Electronic documents can be easily uploaded to Corda nodes and then references to these documents referred to in the relevant Corda states. Any node that has access to the states can then request access to these documents which are then automatically made available. Corda supports all file types as they are saved as in a binary format.
                                    
                                    External Documents which are not stored as part of Corda can be referred to as corda textual references within corda state objects.</b></p>


                                <p><b>Q: What capability is present to bind legal clauses/documents to an instance of a workflow?</p></b> 
                                <p><b>A: </b>Approved and accredited contract code that runs on Corda nodes has references directly to the text (and/or a secure hash) of the legal documents that underpins the transactions on which it applies to. Recall that in the Corda model, “code is not law”, but merely Corda catalyzes the processing between two parties.

                                    Additionally, at any time, if the relevant parties agree, the programmatic code can be upgraded in order to better reflect the underlying contract. A reference to the underlying contract must exist in every corda contract code written, or the developer will not be able to physically compile the code and it will not be approved for certification for running on an R3 approved network. In the case of dispute, the programmatic code will always defer to the legal clause and documents on which it was written for, and Corda will provide the option for parties to use the upgrade path mentioned in order to resolve inconsistencies.</b></p>

                                <p><b>Q: How is consensus achieved on Corda?</p></b> 
                                <p><b>A: </b>We designed Corda from first principles. We took the bits from “blockchain” that work and rejected the rest which were inappropriate for financial services use cases.
                                    Consensus:
                                    
                                    With Corda, the validity of a transaction is established only by the parties to the transaction in question. This is consensus over state validity.
                                    However, consensus over state validity does not prevent two seemingly valid transactions being incompatible, for example, the same state is used as input to two different transactions a “double spend”.
                                    The uniqueness service guarantees that the same state (which represents an asset or agreement) cannot be used for more than one transaction.
                                    When a transaction agreement is reached, the states used as inputs to the transaction are submitted to the uniqueness service for timestamping. Once timestamped, the uniqueness service ensures that any subsequent transactions cannot use those same states.
                                    The uniqueness service could be implemented in multiple ways;
                                    By a standalone centralised server, federated network or decentralised network
                                    By a regulator or consortium of participants
                                    Corda is designed to operate in a substantially different environment, for instance:
                                    All parties using Corda are assigned a cryptographic identity which will be tied to a “real world” identity, such as a legal entity identifier.
                                    It is envisaged that to join the Corda ecosystem, participants must undergo KYC procedures in order to verify these identities.
                                    All smart contracts include legal prose (such as an International Swaps and Derivatives Association agreement) which can be relied upon in the event of a dispute. In effect, all transactions are legally binding through the use of digital signatures.</b></p>

                                <p><b>Q: What are the different encryption and hashing techniques used?</p></b> 
                                <p><b>A: </b>Corda uses the following signature algorithms

                                    RSA
                                    ECDA signature scheme using the secp256k1 Koblitz curve
                                    ECDA signature scheme using the secp256r1 NIST P-256 curve
                                    EdDSA using ed25519 twisted Edwards curve,
                                    SPHINCS-256 hash-based signature scheme (secure against post quantam attacks)
                                    Corda combines the above signatures with SHA256 and SHA512 for hashing. Implementation of HMAC and SHA3-512 are planned for in near future. Additionally data in flight is secured using SSL/TLS. Since Corda is built on a Relational database, it can leverage the capabilities provided by enterprise grade RDBMs e.g. Oracle to secure data at rest.
                                    
                                    </b></p>

                                <p><b>Q: Are there blocks in Corda?</p></b> 
                                <p><b>A: </b>Blocks are required in Bitcoin and other similar DLs to incentivise participants to validate transactions by pooling them together. Participants in proof of work blockchains must incur a cost to validate each other’s transactions. At a minimum, validator’s costs need to be offset.

                                    Given that Bitcoin supports micro payments, it may be the case that if transactions were not pooled into blocks then transaction validation fees may exceed the value of a payment. Therefore transactions are pooled into blocks, aggregating transactions fees, lowering the cost of validation for each individual transaction.
                                    
                                    In Corda, individual contract states reference prior contract states. We have no notion of proof-of-work. Instead notary services perform “uniqueness consensus” and will operate with their own SLAs in place, likely being compensated a fee for their services.</b></p>
                                <p><b>Q: How does Corda address privacy issues?</p></b> 
                                <p><b>A:  </b>Corda was built with privacy concerns at the core. On Corda, data is only shared with those who need to know - those who are a party to the transaction and those with a need to see.

                                    Direct Quote - “Corda is designed to record and manage legal agreements between parties.”
                                    
                                    Ledger is the union of all of these facts; on Corda there is consensus at the agreement level. Once there is consensus, the next question is who are you going to rely on to stamp and validate the transaction? You need a Notary to say yes that transaction occurred and has been committed.
                                    
                                    With Corda:
                                    
                                    Each fact is recorded separately - we specify who receives it, who approves changes, and when it’s accorded a point of finality.
                                    We have digital signatures and business logic (contract code), which is similar to others.
                                    We also have differences – the key difference being data sharing.
                                    The all to all is for where there isn’t a stable identity system and you cannot rely on trusted parties to memorialize transactions or perform services; it requires everyone to check everyone’s work because there is anonymity, no regulation, and no trusted party.</b></p>

                                <p><b>Q: How does Corda scale in terms of number of banks & trade parties?</p></b> 
                                <p><b>A: </b>As the Corda transaction model transmit transactions on a peer to pear mode. This reduces the workload on any given node as it effectively partitioning the overall workload across the network. Thus, there is no “global speed limit” in Corda due to the architecture, so an increase in overall trade volume has no effect on two parties transacting.

                                    Persistence is achieved through the use of enterprise grade RDBMS which already include many scalability features e.g. partitioning, clustering etc. The notaries, which need to sign every transaction can be clustered or multiple notaries could be used.
                                    
                                    Additionally, Corda uses standard technology components, including message queues (Apache Artemis Broker is included, but any AMQP-compliant queueing service may be used), and relational databases (via a JDBC interface). Apache Artemis, an embeddable message queue broke provides journaling, load balancing, flow control, high availability clustering, streaming of messages too large to fit in RAM, automatic delivery retries with backoff etc. Building on enterprise technology components allows Corda to scale up as the trade volumes go up.
                                    
                                    Addition of new banks/trading parties can easily be achieved by either adding the Bank/trading party as a node on the network which is running Corda and securely identifies and authenticates itself to the address and access resources of the network before being allowed to communicate with other peer nodes. As data transmission is done on a point to point basis, the increased number of active nodes has no effect (either on the volume of traffic or latency) on the communication between existing nodes apart from an entry in an address lookup table which is provided by the naming and address provider supplied by Corda.</b></p>


                                <p><b>Q: Is R3 actively researching legal implications of distributed ledger technology?</p></b> 
                                <p><b>A:</b> We have explicitly considered the legal implications of DLT in our design for Corda. In particular, agreements managed in Corda can explicitly link to over-arching legal prose. This enables applications in Corda to bridge from the technical/DLT world to the legal world, providing the possibility that validly signed transactions on Corda can be considered legally binding. These considerations are a direct result of our painstaking, year-long process of architecture and design performed with our large, engaged and diverse membership. It explains why Corda is so unique: it is the only platform that has considered questions such as this from the start.

                                    We are researching legal implications of use of DLT generally, including data privacy, settlement finality, and identity. We are also actively researching compliance with existing regulations for specific use cases. In both efforts, we collaborate with several international and regional law firms as well as lawyers from our consortium members.
                                    
                                    We foresee the new technology in many ways fitting neatly into today’s legal structure. However, there will be legal issues that need to be addressed, for example, settlement finality. Such issues may require a clarification or legislative change.
                                    
                                    </b></p>


                                <p><b>Q: How is reporting done on Corda?</p></b> 
                                <p><b>A: </b>The reports are run on a slave copy of the relational database (EnterpriseDB), thereby not risking to impact the OLTP performance. Since the master-slave replication of the database is done in real-time, any reports run will always depict the latest status and won’t show outdated information.

                                    From a technology point of view, both online and batch reporting will be delivered as Microservices running on top of Spring Boot and leveraging opens source Java reporting frameworks like JasperReports, BIRT or Pentaho to speed up the development. For the estimates and based on the current insights JasperReports has been selected as the reporting framework. However, the final decision to select which reporting framework will be done only during the technical design and after the first reports are defined and clear requirements regarding output formats and look and feel are defined.
                                    
                                    Since underpinning the reporting Microservices Docker is used to scale the overall solution, the number of container instances available for reporting functionality can be easily and dynamically scaled if required. So for example if at 23:00 extra compute resources are required to run the end of day reports, this can be easily catered for without having to scale other components.
                                    
                                    For the scheduling of the various batches including offline reports, like for example end of day reports, the Quartz scheduler will be leveraged.</b></p>


                                <p><b>Q: What are the failure modes of Corda?</p></b> 
                                <p><b>A: </b>The proposed solution takes a robust approach when it comes to redundancy and so all the proposed components are running in a clustered, high available configuration. Docker is leveraged to provide the underlying clustering, fail-over and scaling functionality all components are running in a multi container configuration.
                                    The following setup is selected for the various components:
                                    
                                    API Gateway is running as a software cluster and incoming traffic is being load balanced before it reaches the API gateway.
                                    HSM is running as an appliance cluster.
                                    Database is running as a master-slave configuration in which, in case of failure of the
                                    master, the slave will take on the role of master.
                                    All the microservices (business logic) are running on at least two containers per service and leveraging Docker Swarm to take care of load balancing.
                                    Corda is running in an active-active node configuration.
                                    Besides the above measurements, the underlying storage is also synced to the other datacentre, if applicable, so that in case of disaster recovery the other datacenter can quickly be fully operational and take over the workload.
                                    
                                    In case the bank is hosting the solution on premise this same high availability can be achieved however it is up to the bank to achieve that. If for example a single node HSM is selected instead of a clustered approach there would be the introduction of a single point of failure.</b></p>

                                <p><b>Source: discourse.corda.net</b></p>
                        </div>
						
        </div>
        <!-- jQuery CDN -->
         <script src="https://code.jquery.com/jquery-1.12.0.min.js"></script>
         <!-- Bootstrap Js CDN -->
         <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
         <script type="text/javascript">
             $(document).ready(function () {
                 $('#sidebarCollapse').on('click', function () {
                     $('#sidebar').toggleClass('active');
                 });
             });
		 </script>
		 
		 <!Function to change page when button is pressed on home tab>
<script>
function button(evt, tab){
	
	var i, x, tablinks;
	x = document.getElementsByClassName("tab");
	for (i = 0; i < x.length; i++) {
     		x[i].style.display = "none";
  	}
  	tablinks = document.getElementsByClassName("tablink");
  	for (i = 0; i < x.length; i++) {
      		tablinks[i].className = tablinks[i].className.replace("", ""); 
  	}
  	document.getElementById(tab).style.display = "block";
  	
}
</script>
<script>
		var ask = document.getElementById("question");
		
		ask.addEventListener('click', function() {
			$("#QuestionForm").modal("show");
		
		});
		
		  </script>
    </body>
</html>


